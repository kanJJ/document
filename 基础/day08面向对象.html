<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0065)file:///C:/Users/robin/AppData/Local/Temp/MarkdownPadPreview.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>day08笔记</title>

<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<!--<base href="file:\\\E:\资料\双元模板\day08\day08_source\">--><base href=".">
</head>
<body>
<h3>08.01_面向对象(代码块的概述和分类)(了解)(面试的时候会问,开发不用或者很少用)</h3>
<ul>
<li>
A:代码块概述
<ul>
<li>在Java中，使用{}括起来的代码被称为代码块。</li>
</ul>
</li>
<li>
B:代码块分类
<ul>
<li>根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。</li>
</ul>
</li>
<li>
C:常见代码块的应用
<ul>
<li>
a:局部代码块 
<ul>
<li>在方法中出现；限定变量生命周期，及早释放，提高内存利用率</li>
</ul>
</li>
<li>
b:构造代码块 (初始化块)
<ul>
<li>在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行</li>
</ul>
</li>
<li>
c:静态代码块 
<ul>
<li>在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。</li>
<li>一般用于加载驱动</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>08.02_面向对象(代码块的面试题)(掌握)</h3>
<ul>
<li>A:看程序写结果</li>
<li>
<pre><code>class Student {
    static {
        System.out.println("Student 静态代码块");
    }

    {
        System.out.println("Student 构造代码块");
    }

    public Student() {
        System.out.println("Student 构造方法");
    }
}

class Demo2_Student {
    static {
        System.out.println("Demo2_Student静态代码块");
    }

    public static void main(String[] args) {
        System.out.println("我是main方法");

        Student s1 = new Student();
        Student s2 = new Student();
    }
}
</code></pre>

</li>
</ul>
<h3>08.03_面向对象(继承案例演示)(掌握)</h3>
<ul>
<li>
A:继承(extends)
<ul>
<li>让类与类之间产生关系,子父类关系 </li>
</ul>
</li>
<li>
B:继承案例演示：
<ul>
<li>动物类,猫类,狗类</li>
<li>定义两个属性(颜色,腿的个数)两个功能(吃饭，睡觉)</li>
</ul>
</li>
<li>
C:案例演示
<ul>
<li>使用继承前</li>
</ul>
</li>
<li>
D:案例演示
<ul>
<li>使用继承后</li>
</ul>
</li>
</ul>
<h3>08.04_面向对象(继承的好处和弊端)(掌握)</h3>
<ul>
<li>
A:继承的好处
<ul>
<li>a:提高了代码的复用性</li>
<li>b:提高了代码的维护性</li>
<li>c:让类与类之间产生了关系，是多态的前提</li>
</ul>
</li>
<li>
<p>B:继承的弊端</p>
<ul>
<li>
<p>类的耦合性增强了。</p>
</li>
<li>
<p>开发的原则：高内聚，低耦合。</p>
</li>
<li>耦合：类与类的关系</li>
<li>内聚：就是自己完成某件事情的能力</li>
</ul>
</li>
</ul>
<h3>08.05_面向对象(Java中类的继承特点)(掌握)</h3>
<ul>
<li>
A:Java中类的继承特点
<ul>
<li>
a:Java只支持单继承，不支持多继承。(一个儿子只能有一个爹)
<ul>
<li>有些语言是支持多继承，格式：extends 类1,类2,...</li>
</ul>
</li>
<li>b:Java支持多层继承(继承体系)</li>
</ul>
</li>
<li>
B:案例演示
<ul>
<li>
Java中类的继承特点
<ul>
<li>如果想用这个体系的所有功能用最底层的类创建对象</li>
<li>如果想看这个体系的共性功能,看最顶层的类 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>08.06_面向对象(继承的注意事项和什么时候使用继承)(掌握)</h3>
<ul>
<li>
A:继承的注意事项
<ul>
<li>a:子类只能继承父类所有非私有的成员(成员方法和成员变量)</li>
<li>b:子类不能继承父类的构造方法，但是可以通过super(马上讲)关键字去访问父类构造方法。</li>
<li>c:不要为了部分功能而去继承</li>
<li>项目经理 姓名 工号 工资 奖金</li>
<li>程序员	姓名 工号 工资</li>
</ul>
</li>
<li>
<p>B:什么时候使用继承</p>
<ul>
<li>
继承其实体现的是一种关系："is a"。
Person
	Student
	Teacher
水果
	苹果
	香蕉
	橘子
</li>
</ul>
<p>采用假设法。
	如果有两个类A,B。只有他们符合A是B的一种，或者B是A的一种，就可以考虑使用继承。</p>
</li>
</ul>
<h3>08.07_面向对象(继承中成员变量的关系)(掌握)</h3>
<ul>
<li>
A:案例演示
<ul>
<li>a:不同名的变量</li>
<li>b:同名的变量</li>
</ul>
</li>
</ul>
<h3>08.08_面向对象(this和super的区别和应用)(掌握)</h3>
<ul>
<li>
A:this和super都代表什么
<ul>
<li>this:代表当前对象的引用,谁来调用我,我就代表谁</li>
<li>super:代表当前对象父类的引用</li>
</ul>
</li>
<li>
B:this和super的使用区别
<ul>
<li>
a:调用成员变量
<ul>
<li>this.成员变量 调用本类的成员变量,也可以调用父类的成员变量</li>
<li>super.成员变量 调用父类的成员变量</li>
</ul>
</li>
<li>
b:调用构造方法
<ul>
<li>this(...)	调用本类的构造方法</li>
<li>super(...)	调用父类的构造方法</li>
</ul>
</li>
<li>
c:调用成员方法
<ul>
<li>this.成员方法 调用本类的成员方法,也可以调用父类的方法</li>
<li>super.成员方法 调用父类的成员方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>08.09_面向对象(继承中构造方法的关系)(掌握)</h3>
<ul>
<li>
A:案例演示
<ul>
<li>子类中所有的构造方法默认都会访问父类中空参数的构造方法</li>
</ul>
</li>
<li>
<p>B:为什么呢?</p>
<ul>
<li>因为子类会继承父类中的数据，可能还会使用父类的数据。</li>
<li>
<p>所以，子类初始化之前，一定要先完成父类数据的初始化。</p>
</li>
<li>
<p>其实：</p>
<ul>
<li>每一个构造方法的第一条语句默认都是：super() Object类最顶层的父类。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>08.10_面向对象(继承中构造方法的注意事项)(掌握)</h3>
<ul>
<li>
A:案例演示
<ul>
<li>父类没有无参构造方法,子类怎么办?</li>
<li>super解决</li>
<li>this解决</li>
</ul>
</li>
<li>
B:注意事项
<ul>
<li>super(…)或者this(….)必须出现在构造方法的第一条语句上</li>
</ul>
</li>
</ul>
<h3>08.11_面向对象(继承中的面试题)(掌握)</h3>
<ul>
<li>A:案例演示</li>
<li>
<pre><code>看程序写结果1
class Fu{
    public int num = 10;
    public Fu(){
        System.out.println("fu");
    }
}
class Zi extends Fu{
    public int num = 20;
    public Zi(){
        System.out.println("zi");
    }
    public void show(){
        int num = 30;
        System.out.println(num);
        System.out.println(this.num);
        System.out.println(super.num);
    }
}
class Test1_Extends {
    public static void main(String[] args) {
        Zi z = new Zi();
        z.show();
    }
}

看程序写结果2
class Fu {
    static {
        System.out.println("静态代码块Fu");
    }

    {
        System.out.println("构造代码块Fu");
    }

    public Fu() {
        System.out.println("构造方法Fu");
    }
}

class Zi extends Fu {
    static {
        System.out.println("静态代码块Zi");
    }

    {
        System.out.println("构造代码块Zi");
    }

    public Zi() {
        System.out.println("构造方法Zi");
    }
}

Zi z = new Zi(); 请执行结果。
</code></pre>

</li>
</ul>
<h3>08.12_面向对象(继承中成员方法关系)(掌握)</h3>
<ul>
<li>
A:案例演示
<ul>
<li>a:不同名的方法</li>
<li>b:同名的方法</li>
</ul>
</li>
</ul>
<h3>08.13_面向对象(方法重写概述及其应用)(掌握)</h3>
<ul>
<li>
A:什么是方法重写
<ul>
<li>重写:子父类出现了一模一样的方法(注意:返回值类型可以是子父类,这个我们学完面向对象讲) </li>
</ul>
</li>
<li>
B:方法重写的应用：
<ul>
<li>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。</li>
</ul>
</li>
<li>
C:案例演示
<ul>
<li>a:定义一个手机类。</li>
</ul>
</li>
</ul>
<h3>08.14_面向对象(方法重写的注意事项)(掌握)</h3>
<ul>
<li>
<p>A:方法重写注意事项</p>
<ul>
<li>
a:父类中私有方法不能被重写
<ul>
<li>因为父类私有方法子类根本就无法继承</li>
</ul>
</li>
<li>
b:子类重写父类方法时，访问权限不能更低
<ul>
<li>最好就一致</li>
</ul>
</li>
<li>
<p>c:父类静态方法，子类也必须通过静态方法进行重写</p>
<ul>
<li>其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解(静态只能覆盖静态)</li>
</ul>
</li>
<li>
<p>子类重写父类方法的时候，最好声明一模一样。</p>
</li>
</ul>
</li>
<li>
B:案例演示
<ul>
<li>方法重写注意事项</li>
</ul>
</li>
</ul>
<h3>08.15_面向对象(方法重写的面试题)(掌握)</h3>
<ul>
<li>
<p>A:方法重写的面试题</p>
<ul>
<li>Override和Overload的区别?Overload能改变返回值类型吗?</li>
<li>overload可以改变返回值类型,只看参数列表</li>
<li>
<p>方法重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值是一致(或者是子父类)的</p>
</li>
<li>
<p>方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。</p>
</li>
<li>
<p>子类对象调用方法的时候：</p>
<ul>
<li>先找子类本身，再找父类。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>08.16_面向对象(使用继承前的学生和老师案例)(掌握)</h3>
<ul>
<li>
A:案例演示
<ul>
<li>使用继承前的学生和老师案例</li>
<li>属性:姓名,年龄</li>
<li>行为:吃饭</li>
<li>老师有特有的方法:讲课</li>
<li>学生有特有的方法:学习</li>
</ul>
</li>
</ul>
<h3>08.17_面向对象(使用继承后的学生和老师案例)(掌握)</h3>
<ul>
<li>
A:案例演示
<ul>
<li>使用继承后的学生和老师案例</li>
</ul>
</li>
</ul>
<h3>08.18_面向对象(猫狗案例分析,实现及测试)(掌握)</h3>
<ul>
<li>A:猫狗案例分析</li>
<li>
B:案例演示
<ul>
<li>猫狗案例继承版</li>
<li>属性:毛的颜色,腿的个数</li>
<li>行为:吃饭</li>
<li>猫特有行为:抓老鼠catchMouse</li>
<li>狗特有行为:看家lookHome</li>
</ul>
</li>
</ul>
<h3>08.19_面向对象(final关键字修饰类,方法以及变量的特点)(掌握)</h3>
<ul>
<li>A:final概述</li>
<li>
B:final修饰特点
<ul>
<li>修饰类，类不能被继承</li>
<li>修饰变量，变量就变成了常量，只能被赋值一次</li>
<li>修饰方法，方法不能被重写</li>
</ul>
</li>
<li>
C:案例演示
<ul>
<li>final修饰特点</li>
</ul>
</li>
</ul>
<h3>08.20_面向对象(final关键字修饰局部变量)(掌握)</h3>
<ul>
<li>
<p>A:案例演示</p>
<ul>
<li>
<p>方法内部或者方法声明上都演示一下(了解)</p>
</li>
<li>
<p>基本类型，是值不能被改变</p>
</li>
<li>引用类型，是地址值不能被改变,对象中的属性可以改变</li>
</ul>
</li>
</ul>
<h3>08.21_面向对象(final修饰变量的初始化时机)(掌握)</h3>
<ul>
<li>
A:final修饰变量的初始化时机
<ul>
<li>显示初始化 </li>
<li>在对象构造完毕前即可</li>
</ul>
</li>
</ul>
<h3>08.22_day08总结</h3>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>



<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
</body></html>