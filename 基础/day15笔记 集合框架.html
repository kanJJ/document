<!DOCTYPE html>
<!-- saved from url=(0065)file:///C:/Users/robin/AppData/Local/Temp/MarkdownPadPreview.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>day15笔记</title>

<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<!--<base href="file:\\\E:\资料\双元模板\day15\day15_source\">--><base href=".">
</head>
<body>
<h3>15.01_集合框架(对象数组的概述和使用)</h3>
<ul>
<li>
A:案例演示
<ul>
<li>需求：我有5个学生，请把这个5个学生的信息存储到数组中，并遍历数组，获取得到每一个学生信息。</li>
</ul>
</li>
<li>
<pre><code>Student[] arr = new Student[5];                 //存储学生对象
arr[0] = new Student("张三", 23);
arr[1] = new Student("李四", 24);
arr[2] = new Student("王五", 25);
arr[3] = new Student("赵六", 26);
arr[4] = new Student("马哥", 20);

for (int i = 0; i &lt; arr.length; i++) {
    System.out.println(arr[i]);
}
</code></pre>

</li>
<li>
<p>B:画图演示</p>
<ul>
<li>把学生数组的案例画图讲解</li>
<li>数组和集合存储引用数据类型,存的都是地址值</li>
</ul>
</li>
</ul>
<h3>15.02_集合框架(集合的由来及集合继承体系图)</h3>
<ul>
<li>
A:集合的由来
<ul>
<li>数组长度是固定,当添加的元素超过了数组的长度时需要对数组重新定义,太麻烦,java内部给我们提供了集合类,能存储任意对象,长度是可以改变的,随着元素的增加而增加,随着元素的减少而减少 </li>
</ul>
</li>
<li>
B:数组和集合的区别
<ul>
<li>
区别1 : 
<ul>
<li>数组既可以存储基本数据类型,又可以存储引用数据类型,基本数据类型存储的是值,引用数据类型存储的是地址值</li>
<li>集合只能存储引用数据类型(对象)集合中也可以存储基本数据类型,但是在存储的时候会自动装箱变成对象</li>
</ul>
</li>
<li>
区别2:
<ul>
<li>数组长度是固定的,不能自动增长</li>
<li>集合的长度的是可变的,可以根据元素的增加而增长</li>
</ul>
</li>
</ul>
</li>
<li>
C:数组和集合什么时候用
	* 1,如果元素个数是固定的推荐用数组
	* 2,如果元素个数不是固定的推荐用集合
</li>
<li>D:集合继承体系图</li>
</ul>
<h3>15.03_集合框架(Collection集合的基本功能测试)</h3>
<ul>
<li>A:案例演示	</li>
<li>
<pre><code>基本功能演示

boolean add(E e)
boolean remove(Object o)
void clear()
boolean contains(Object o)
boolean isEmpty()
int size()
</code></pre>

</li>
<li>
<p>B:注意:</p>
</li>
<li>
<pre><code>collectionXxx.java使用了未经检查或不安全的操作.
注意:要了解详细信息,请使用 -Xlint:unchecked重新编译.
java编译器认为该程序存在安全隐患
温馨提示:这不是编译失败,所以先不用理会,等学了泛型你就知道了
</code></pre>

</li>
</ul>
<h3>15.04_集合框架(集合的遍历之集合转数组遍历)</h3>
<ul>
<li>
A:集合的遍历
<ul>
<li>其实就是依次获取集合中的每一个元素。</li>
</ul>
</li>
<li>
<p>B:案例演示</p>
<ul>
<li>把集合转成数组，可以实现集合的遍历</li>
<li>
<p>toArray()
*</p>
<pre><code>Collection coll = new ArrayList();
coll.add(new Student("张三",23));     //Object obj = new Student("张三",23);
coll.add(new Student("李四",24));
coll.add(new Student("王五",25));
coll.add(new Student("赵六",26));

Object[] arr = coll.toArray();              //将集合转换成数组
for (int i = 0; i &lt; arr.length; i++) {
    Student s = (Student)arr[i];            //强转成Student
    System.out.println(s.getName() + "," + s.getAge());
}
</code></pre>

</li>
</ul>
</li>
</ul>
<h3>15.05_集合框架(Collection集合的带All功能测试)</h3>
<ul>
<li>A:案例演示</li>
<li>
<pre><code>带All的功能演示

boolean addAll(Collection c)
boolean removeAll(Collection c)
boolean containsAll(Collection c)
boolean retainAll(Collection c)
</code></pre>

</li>
</ul>
<h3>15.06_集合框架(集合的遍历之迭代器遍历)</h3>
<ul>
<li>
A:迭代器概述
<ul>
<li>集合是用来存储元素,存储的元素需要查看,那么就需要迭代(遍历) </li>
</ul>
</li>
<li>
<p>B:案例演示</p>
<ul>
<li>
<p>迭代器的使用</p>
<pre><code>Collection c = new ArrayList();
c.add("a");
c.add("b");
c.add("c");
c.add("d");

Iterator it = c.iterator();                     //获取迭代器的引用
while(it.hasNext()) {                           //集合中的迭代方法(遍历)
    System.out.println(it.next());
}
</code></pre>

</li>
</ul>
</li>
</ul>
<h3>15.07_集合框架(Collection存储自定义对象并遍历)</h3>
<ul>
<li>
<p>A:案例演示</p>
<ul>
<li>Collection存储自定义对象并用迭代器遍历</li>
<li>
<pre><code>Collection c = new ArrayList();

c.add(new Student("张三",23));
c.add(new Student("李四",24));
c.add(new Student("王五",25));
c.add(new Student("赵六",26));
c.add(new Student("赵六",26));

for(Iterator it = c.iterator();it.hasNext();) {
    Student s = (Student)it.next();                     //向下转型
    System.out.println(s.getName() + "," + s.getAge()); //获取对象中的姓名和年龄
}
System.out.println("------------------------------");
Iterator it = c.iterator();                             //获取迭代器
while(it.hasNext()) {                                   //判断集合中是否有元素
    //System.out.println(((Student)(it.next())).getName() + "," + ((Student)(it.next())).getAge());
    Student s = (Student)it.next();                     //向下转型
    System.out.println(s.getName() + "," + s.getAge()); //获取对象中的姓名和年龄
}
</code></pre>

</li>
</ul>
</li>
</ul>
<h3>15.08_集合框架(迭代器的原理及源码解析)(了解)</h3>
<ul>
<li>
A:迭代器原理
<ul>
<li>迭代器原理:迭代器是对集合进行遍历,而每一个集合内部的存储结构都是不同的,所以每一个集合存和取都是不一样,那么就需要在每一个类中定义hasNext()和next()方法,这样做是可以的,但是会让整个集合体系过于臃肿,迭代器是将这样的方法向上抽取出接口,然后在每个类的内部,定义自己迭代方式,这样做的好处有二,第一规定了整个集合体系的遍历方式都是hasNext()和next()方法,第二,代码有底层内部实现,使用者不用管怎么实现的,会用即可 </li>
</ul>
</li>
<li>
B:迭代器源码解析
<ul>
<li>1,在eclipse中ctrl + shift + t找到ArrayList类</li>
<li>2,ctrl+o查找iterator()方法</li>
<li>3,查看返回值类型是new Itr(),说明Itr这个类实现Iterator接口</li>
<li>4,查找Itr这个内部类,发现重写了Iterator中的所有抽象方法 </li>
</ul>
</li>
</ul>
<h3>15.09_集合框架(List集合的特有功能概述和测试)</h3>
<ul>
<li>
A:List集合的特有功能概述
<ul>
<li>void add(int index,E element)</li>
<li>E remove(int index)</li>
<li>E get(int index)</li>
<li>E set(int index,E element)</li>
</ul>
</li>
</ul>
<h3>15.10_集合框架(List集合存储学生对象并遍历)</h3>
<ul>
<li>
<p>A:案例演示</p>
<ul>
<li>
<p>通过size()和get()方法结合使用遍历。</p>
<pre><code>List list = new ArrayList();
list.add(new Student("张三", 18));
list.add(new Student("李四", 18));
list.add(new Student("王五", 18));
list.add(new Student("赵六", 18));

for(int i = 0; i &lt; list.size(); i++) {
    Student s = (Student)list.get(i);
    System.out.println(s.getName() + "," + s.getAge());
}
</code></pre>

</li>
</ul>
</li>
</ul>
<h3>15.11_集合框架(并发修改异常产生的原因及解决方案)</h3>
<ul>
<li>
<p>A:案例演示</p>
<ul>
<li>
<p>需求：我有一个集合，请问，我想判断里面有没有"world"这个元素，如果有，我就添加一个"javaee"元素，请写代码实现。</p>
<pre><code>List list = new ArrayList();
list.add("a");
list.add("b");
list.add("world");
list.add("d");
list.add("e");

/*Iterator it = list.iterator();
while(it.hasNext()) {
    String str = (String)it.next();
    if(str.equals("world")) {
        list.add("javaee");         //这里会抛出ConcurrentModificationException并发修改异常
    }
}*/
</code></pre>

</li>
</ul>
</li>
<li>
<p>B:ConcurrentModificationException出现</p>
<ul>
<li>迭代器遍历，集合修改集合</li>
</ul>
</li>
<li>
<p>C:解决方案</p>
<ul>
<li>a:迭代器迭代元素，迭代器修改元素(ListIterator的特有功能add)</li>
<li>
<p>b:集合遍历元素，集合修改元素</p>
<pre><code>ListIterator lit = list.listIterator();     //如果想在遍历的过程中添加元素,可以用ListIterator中的add方法
while(lit.hasNext()) {
    String str = (String)lit.next();
    if(str.equals("world")) {
        lit.add("javaee");  
        //list.add("javaee");
    }
}
</code></pre>

</li>
</ul>
</li>
</ul>
<h3>15.12_集合框架(ListIterator)(了解)</h3>
<ul>
<li>boolean hasNext()是否有下一个</li>
<li>boolean hasPrevious()是否有前一个</li>
<li>Object next()返回下一个元素</li>
<li>Object previous();返回上一个元素</li>
</ul>
<h3>15.13_集合框架(Vector的特有功能)</h3>
<ul>
<li>A:Vector类概述</li>
<li>
B:Vector类特有功能
<ul>
<li>public void addElement(E obj)</li>
<li>public E elementAt(int index)</li>
<li>public Enumeration elements()</li>
</ul>
</li>
<li>
<p>C:案例演示	</p>
<ul>
<li>
<p>Vector的迭代</p>
<pre><code>Vector v = new Vector();                //创建集合对象,List的子类
v.addElement("a");
v.addElement("b");
v.addElement("c");
v.addElement("d");

//Vector迭代
Enumeration en = v.elements();          //获取枚举
while(en.hasMoreElements()) {           //判断集合中是否有元素
    System.out.println(en.nextElement());//获取集合中的元素
}
</code></pre>

</li>
</ul>
</li>
</ul>
<h3>15.14_集合框架(数据结构之数组和链表)</h3>
<ul>
<li>
A:数组
<ul>
<li>查询快修改也快</li>
<li>增删慢</li>
</ul>
</li>
<li>
B:链表
<ul>
<li>查询慢,修改也慢</li>
<li>增删快</li>
</ul>
</li>
</ul>
<h3>15.15_集合框架(List的三个子类的特点)</h3>
<ul>
<li>A:List的三个子类的特点</li>
<li>
<pre><code>ArrayList:
    底层数据结构是数组，查询快，增删慢。
    线程不安全，效率高。
Vector:
    底层数据结构是数组，查询快，增删慢。
    线程安全，效率低。
Vector相对ArrayList查询慢(线程安全的)
Vector相对LinkedList增删慢(数组结构)
LinkedList:
    底层数据结构是链表，查询慢，增删快。
    线程不安全，效率高。

Vector和ArrayList的区别
    Vector是线程安全的,效率低
    ArrayList是线程不安全的,效率高
共同点:都是数组实现的
ArrayList和LinkedList的区别
    ArrayList底层是数组结果,查询和修改快
    LinkedList底层是链表结构的,增和删比较快,查询和修改比较慢
共同点:都是线程不安全的
</code></pre>

</li>
<li>
B:List有三个儿子，我们到底使用谁呢?
	查询多用ArrayList
	增删多用LinkedList
	如果都多ArrayList
</li>
</ul>
<h3>15.16_day15总结</h3>
<p>把今天的知识点总结一遍。</p>



<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
</body></html>