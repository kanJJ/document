<!DOCTYPE html>
<!-- saved from url=(0065)file:///C:/Users/robin/AppData/Local/Temp/MarkdownPadPreview.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>day21笔记</title>

<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<!--<base href="file:\\\E:\资料\双元模板\day21\day21_resource\">--><base href=".">
</head>
<body>
<h3>21.01_IO流(字符流FileReader)</h3>
<ul>
<li>
1.字符流是什么
<ul>
<li>字符流是可以直接读写字符的IO流</li>
<li>字符流读取字符, 就要先读取到字节数据, 然后转为字符. 如果要写出字符, 需要把字符转为字节再写出.    
</li>
</ul>
</li>
<li>
2.FileReader
<ul>
<li>FileReader类的read()方法可以按照字符大小读取</li>
</ul>
</li>
<li>
<pre><code>FileReader fr = new FileReader("aaa.txt");              //创建输入流对象,关联aaa.txt
int ch;
while((ch = fr.read()) != -1) {                         //将读到的字符赋值给ch
    System.out.println((char)ch);                       //将读到的字符强转后打印
}

fr.close();                                             //关流 
</code></pre>

</li>
</ul>
<h3>21.02_IO流(字符流FileWriter)</h3>
<ul>
<li>
<p>FileWriter类的write()方法可以自动把字符转为字节写出</p>
<pre><code>FileWriter fw = new FileWriter("aaa.txt");
fw.write("aaa");
fw.close();
</code></pre>

</li>
</ul>
<h3>21.03_IO流(字符流的拷贝)</h3>
<pre><code>FileReader fr = new FileReader("a.txt");
FileWriter fw = new FileWriter("b.txt");

int ch;
while((ch = fr.read()) != -1) {
    fw.write(ch);
}

fr.close();
fw.close();
</code></pre>

<h3>21.04_IO流(什么情况下使用字符流)</h3>
<ul>
<li>字符流也可以拷贝文本文件, 但不推荐使用. 因为读取时会把字节转为字符, 写出时还要把字符转回字节.</li>
<li>程序需要读取一段文本, 或者需要写出一段文本的时候可以使用字符流</li>
<li>读取的时候是按照字符的大小读取的,不会出现半个中文</li>
<li>写出的时候可以直接将字符串写出,不用转换为字节数组</li>
</ul>
<h3>21.05_IO流(字符流是否可以拷贝非纯文本的文件)</h3>
<ul>
<li>不可以拷贝非纯文本的文件</li>
<li>因为在读的时候会将字节转换为字符,在转换过程中,可能找不到对应的字符,就会用?代替,写出的时候会将字符转换成字节写出去</li>
<li>如果是?,直接写出,这样写出之后的文件就乱了,看不了了  
</li>
</ul>
<h3>21.06_IO流(自定义字符数组的拷贝)</h3>
<ul>
<li>
<pre><code>FileReader fr = new FileReader("aaa.txt");          //创建字符输入流,关联aaa.txt
FileWriter fw = new FileWriter("bbb.txt");          //创建字符输出流,关联bbb.txt

int len;
char[] arr = new char[1024*8];                      //创建字符数组
while((len = fr.read(arr)) != -1) {                 //将数据读到字符数组中
    fw.write(arr, 0, len);                          //从字符数组将数据写到文件上
}

fr.close();                                         //关流释放资源
fw.close(); 
</code></pre>

</li>
</ul>
<h3>21.07_IO流(带缓冲的字符流)</h3>
<ul>
<li>BufferedReader的read()方法读取字符时会一次读取若干字符到缓冲区, 然后逐个返回给程序, 降低读取文件的次数, 提高效率</li>
<li>BufferedWriter的write()方法写出字符时会先写到缓冲区, 缓冲区写满时才会写到文件, 降低写文件的次数, 提高效率</li>
<li>
<pre><code>BufferedReader br = new BufferedReader(new FileReader("aaa.txt"));  //创建字符输入流对象,关联aaa.txt
BufferedWriter bw = new BufferedWriter(new FileWriter("bbb.txt"));  //创建字符输出流对象,关联bbb.txt

int ch;             
while((ch = br.read()) != -1) {     //read一次,会先将缓冲区读满,从缓冲去中一个一个的返给临时变量ch
    bw.write(ch);                   //write一次,是将数据装到字符数组,装满后再一起写出去
}

br.close();                         //关流
bw.close();  
</code></pre>

</li>
</ul>
<h3>21.08_IO流(readLine()和newLine()方法)</h3>
<ul>
<li>BufferedReader的readLine()方法可以读取一行字符(不包含换行符号)</li>
<li>BufferedWriter的newLine()可以输出一个跨平台的换行符号"\r\n"</li>
<li>
<pre><code>BufferedReader br = new BufferedReader(new FileReader("aaa.txt"));
BufferedWriter bw = new BufferedWriter(new FileWriter("bbb.txt"));
String line;
while((line = br.readLine()) != null) {
    bw.write(line);
    //bw.write("\r\n");                 //只支持windows系统
    bw.newLine();                       //跨平台的
}

br.close();
bw.close(); 
</code></pre>

</li>
</ul>
<h3>21.09_IO流(将文本反转)</h3>
<ul>
<li>将一个文本文档上的文本反转,第一行和倒数第一行交换,第二行和倒数第二行交换</li>
</ul>
<h3>21.10_IO流(LineNumberReader)</h3>
<ul>
<li>
LineNumberReader是BufferedReader的子类, 具有相同的功能, 并且可以统计行号
<ul>
<li>调用getLineNumber()方法可以获取当前行号</li>
<li>调用setLineNumber()方法可以设置当前行号</li>
</ul>
</li>
<li>
<pre><code>LineNumberReader lnr = new LineNumberReader(new FileReader("aaa.txt"));
String line;
lnr.setLineNumber(100);                                 //设置行号
while((line = lnr.readLine()) != null) {
    System.out.println(lnr.getLineNumber() + ":" + line);//获取行号
}

lnr.close(); 
</code></pre>

</li>
</ul>
<h3>21.11_IO流(装饰设计模式)</h3>
<ul>
<li>
<pre><code>interface Coder {
    public void code();
}

class Student implements Coder {

    @Override
    public void code() {
        System.out.println("javase");
        System.out.println("javaweb");
    }

}

class HeiMaStudent implements Coder {
    private Student s;                      //获取到被包装的类的引用
    public ItcastStudent(Student s) {       //通过构造函数创建对象的时候,传入被包装的对象
        this.s = s;
    }
    @Override
    public void code() {                    //对其原有功能进行升级
        s.code();
        System.out.println("数据库");
        System.out.println("ssh");
        System.out.println("安卓");
        System.out.println(".....");
    }

} 
</code></pre>

</li>
</ul>
<h3>21.12_IO流(使用指定的码表读写字符)</h3>
<ul>
<li>FileReader是使用默认码表读取文件, 如果需要使用指定码表读取, 那么可以使用InputStreamReader(字节流,编码表)</li>
<li>FileWriter是使用默认码表写出文件, 如果需要使用指定码表写出, 那么可以使用OutputStreamWriter(字节流,编码表)</li>
<li>
<pre><code>BufferedReader br =                                     //高效的用指定的编码表读
        new BufferedReader(new InputStreamReader(new FileInputStream("UTF-8.txt"), "UTF-8"));
BufferedWriter bw =                                     //高效的用指定的编码表写
        new BufferedWriter(new OutputStreamWriter(new FileOutputStream("GBK.txt"), "GBK"));
int ch;
while((ch = br.read()) != -1) {
    bw.write(ch);
}

br.close();
bw.close();
</code></pre>

</li>
</ul>
<h3>21.13_IO流(转换流图解)</h3>
<ul>
<li>画图分析转换流</li>
</ul>
<h3>21.14_IO流(获取文本上字符出现的次数)</h3>
<ul>
<li>获取一个文本上每个字符出现的次数,将结果写在times.txt上</li>
</ul>
<h3>21.15_IO流(试用版软件)</h3>
<ul>
<li>当我们下载一个试用版软件,没有购买正版的时候,每执行一次就会提醒我们还有多少次使用机会用学过的IO流知识,模拟试用版软件,试用10次机会,执行一次就提示一次您还有几次机会,如果次数到了提示请购买正版</li>
</ul>
<h3>21.16_File类(递归)</h3>
<ul>
<li>5的阶乘	</li>
</ul>
<h3>21.17_File类(练习)</h3>
<ul>
<li>需求:从键盘输入接收一个文件夹路径,打印出该文件夹下所有的.java文件名</li>
</ul>
<h3>21.18_IO流(总结)</h3>
<ul>
<li>1.会用BufferedReader读取GBK码表和UTF-8码表的字符</li>
<li>2.会用BufferedWriter写出字符到GBK码表和UTF-8码表的文件中</li>
<li>3.会使用BufferedReader从键盘读取一行</li>
</ul>



<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
</body></html>