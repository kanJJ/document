<!DOCTYPE html>
<!-- saved from url=(0065)file:///C:/Users/robin/AppData/Local/Temp/MarkdownPadPreview.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>day26笔记</title>

<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<!--<base href="file:\\\E:\资料\双元模板\day26\day26_resource\">--><base href=".">
</head>
<body>
<p>day26授课目录：</p>
<h3>26.01_网络编程(网络编程概述)(了解)</h3>
<ul>
<li>
A:计算机网络
<ul>
<li>是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</li>
</ul>
</li>
<li>
B:网络编程
<ul>
<li>就是用来实现网络互连的不同计算机上运行的程序间可以进行数据交换。</li>
</ul>
</li>
</ul>
<h3>26.02_网络编程(网络编程三要素之IP概述)(掌握)</h3>
<ul>
<li>每个设备在网络中的唯一标识</li>
<li>每台网络终端在网络中都有一个独立的地址，我们在网络中传输数据就是使用这个地址。 </li>
<li>ipconfig：查看本机IP192.168.12.42</li>
<li>ping：测试连接192.168.40.62</li>
<li>本地回路地址：127.0.0.1 255.255.255.255是广播地址</li>
<li>IPv4：4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已经用尽。 </li>
<li>IPv6：8组，每组4个16进制数。</li>
<li>1a2b:0000:aaaa:0000:0000:0000:aabb:1f2f</li>
<li>1a2b::aaaa:0000:0000:0000:aabb:1f2f</li>
<li>1a2b:0000:aaaa::aabb:1f2f</li>
<li>1a2b:0000:aaaa::0000:aabb:1f2f</li>
<li>1a2b:0000:aaaa:0000::aabb:1f2f</li>
</ul>
<h3>26.03_网络编程(网络编程三要素之端口号概述)(掌握)</h3>
<ul>
<li>每个程序在设备上的唯一标识</li>
<li>每个网络程序都需要绑定一个端口号，传输数据的时候除了确定发到哪台机器上，还要明确发到哪个程序。</li>
<li>端口号范围从0-65535</li>
<li>编写网络应用就需要绑定一个端口号，尽量使用1024以上的，1024以下的基本上都被系统程序占用了。</li>
<li>
常用端口
<ul>
<li>mysql: 3306</li>
<li>oracle: 1521</li>
<li>web: 80</li>
<li>tomcat: 8080</li>
<li>QQ: 4000</li>
<li>feiQ: 2425</li>
</ul>
</li>
</ul>
<h3>26.04_网络编程(网络编程三要素协议)(掌握)</h3>
<ul>
<li>为计算机网络中进行数据交换而建立的规则、标准或约定的集合。</li>
<li>
UDP
<ul>
<li>面向无连接，数据不安全，速度快。不区分客户端与服务端。</li>
</ul>
</li>
<li>
TCP
　　* 面向连接（三次握手），数据安全，速度略低。分为客户端和服务端。
<ul>
<li>三次握手: 客户端先向服务端发起请求, 服务端响应请求, 传输数据</li>
</ul>
</li>
</ul>
<h3>26.05_网络编程(Socket通信原理图解)(了解)</h3>
<ul>
<li>
A:Socket套接字概述：
<ul>
<li>网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。</li>
<li>通信的两端都有Socket。</li>
<li>网络通信其实就是Socket间的通信。</li>
<li>数据在两个Socket间通过IO流传输。</li>
<li>Socket在应用程序中创建，通过一种绑定机制与驱动程序建立关系，告诉自己所对应的IP和port。</li>
</ul>
</li>
</ul>
<h3>26.06_网络编程(UDP传输)(了解)</h3>
<ul>
<li>
1.发送Send
<ul>
<li>创建DatagramSocket, 随机端口号</li>
<li>创建DatagramPacket, 指定数据, 长度, 地址, 端口</li>
<li>使用DatagramSocket发送DatagramPacket</li>
<li>关闭DatagramSocket</li>
</ul>
</li>
<li>
2.接收Receive
<ul>
<li>创建DatagramSocket, 指定端口号</li>
<li>创建DatagramPacket, 指定数组, 长度</li>
<li>使用DatagramSocket接收DatagramPacket</li>
<li>关闭DatagramSocket</li>
<li>从DatagramPacket中获取数据</li>
</ul>
</li>
<li>
3.接收方获取ip和端口号
<ul>
<li>String ip = packet.getAddress().getHostAddress();</li>
<li>int port = packet.getPort();</li>
</ul>
</li>
</ul>
<h3>26.07_网络编程(UDP传输优化)</h3>
<ul>
<li>接收端Receive</li>
<li>
<pre><code>DatagramSocket socket = new DatagramSocket(6666);                       //创建socket相当于创建码头
DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);       //创建packet相当于创建集装箱

while(true) {
    socket.receive(packet);                                             //接收货物
    byte[] arr = packet.getData();
    int len = packet.getLength();
    String ip = packet.getAddress().getHostAddress();
    System.out.println(ip + ":" + new String(arr,0,len));
}
</code></pre>

</li>
<li>
<p>发送端Send</p>
<pre><code>DatagramSocket socket = new DatagramSocket();       //创建socket相当于创建码头
Scanner sc = new Scanner(System.in);

while(true) {
    String str = sc.nextLine();
    if("quit".equals(str))
        break;
    DatagramPacket packet =                             //创建packet相当于创建集装箱
            new DatagramPacket(str.getBytes(), str.getBytes().length, InetAddress.getByName("127.0.0.1"), 6666);
    socket.send(packet);            //发货
}
socket.close();
</code></pre>

</li>
</ul>
<h3>26.08_网络编程(UDP传输多线程)</h3>
<ul>
<li>
<p>A发送和接收在一个窗口完成</p>
<pre><code>public class Demo3_MoreThread {

    /**
     * @param args
     */
    public static void main(String[] args) {
        new Receive().start();

        new Send().start();
    }

}

class Receive extends Thread {
    public void run() {
        try {
            DatagramSocket socket = new DatagramSocket(6666);                   //创建socket相当于创建码头
            DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);   //创建packet相当于创建集装箱

            while(true) {
                socket.receive(packet);                                             //接收货物
                byte[] arr = packet.getData();
                int len = packet.getLength();
                String ip = packet.getAddress().getHostAddress();
                System.out.println(ip + ":" + new String(arr,0,len));
            }
        } catch (IOException e) {

            e.printStackTrace();
        }
    }
}

class Send extends Thread {
    public void run() {
        try {
            DatagramSocket socket = new DatagramSocket();       //创建socket相当于创建码头
            Scanner sc = new Scanner(System.in);

            while(true) {
                String str = sc.nextLine();
                if("quit".equals(str))
                    break;
                DatagramPacket packet =                             //创建packet相当于创建集装箱
                        new DatagramPacket(str.getBytes(), str.getBytes().length, InetAddress.getByName("127.0.0.1"), 6666);
                socket.send(packet);            //发货
            }
            socket.close();
        }  catch (IOException e) {

            e.printStackTrace();
        }
    }
}
</code></pre>

</li>
</ul>
<h3>26.09_网络编程(UDP聊天图形化界面)</h3>
<h3>26.10_网络编程(UDP聊天发送功能)</h3>
<h3>26.11_网络编程(UDP聊天记录功能)</h3>
<h3>26.12_网络编程(UDP聊天清屏功能)</h3>
<h3>26.13_网络编程(UDP聊天震动功能)</h3>
<h3>26.14_网络编程(UDP聊天快捷键和代码优化)</h3>
<h3>26.15_网络编程(UDP聊天生成jar文件)</h3>
<h3>26.16_网络编程(TCP协议)(掌握)</h3>
<ul>
<li>
1.客户端
<ul>
<li>创建Socket连接服务端(指定ip地址,端口号)通过ip地址找对应的服务器</li>
<li>调用Socket的getInputStream()和getOutputStream()方法获取和服务端相连的IO流</li>
<li>输入流可以读取服务端输出流写出的数据</li>
<li>输出流可以写出数据到服务端的输入流</li>
</ul>
</li>
<li>
2.服务端
<ul>
<li>创建ServerSocket(需要指定端口号)</li>
<li>调用ServerSocket的accept()方法接收一个客户端请求，得到一个Socket</li>
<li>调用Socket的getInputStream()和getOutputStream()方法获取和客户端相连的IO流</li>
<li>输入流可以读取客户端输出流写出的数据</li>
<li>输出流可以写出数据到客户端的输入流</li>
</ul>
</li>
</ul>
<h3>26.17_网络编程(TCP协议代码优化)</h3>
<ul>
<li>
<p>客户端</p>
<pre><code>Socket socket = new Socket("127.0.0.1", 9999);      //创建Socket指定ip地址和端口号
InputStream is = socket.getInputStream();           //获取输入流
OutputStream os = socket.getOutputStream();         //获取输出流
BufferedReader br = new BufferedReader(new InputStreamReader(is));
PrintStream ps = new PrintStream(os);

System.out.println(br.readLine());
ps.println("我想报名就业班");
System.out.println(br.readLine());
ps.println("爷不学了");
socket.close();
</code></pre>

</li>
<li>
<p>服务端</p>
<pre><code>ServerSocket server = new ServerSocket(9999);   //创建服务器
Socket socket = server.accept();                //接受客户端的请求
InputStream is = socket.getInputStream();       //获取输入流
OutputStream os = socket.getOutputStream();     //获取输出流

BufferedReader br = new BufferedReader(new InputStreamReader(is));
PrintStream ps = new PrintStream(os);

ps.println("欢迎咨询传智播客");
System.out.println(br.readLine());
ps.println("报满了,请报下一期吧");
System.out.println(br.readLine());
server.close();
socket.close();
</code></pre>

</li>
</ul>
<h3>26.18_网络编程(服务端是多线程的)(掌握)</h3>
<pre><code>ServerSocket server = new ServerSocket(9999);   //创建服务器
    while(true) {
        final Socket socket = server.accept();              //接受客户端的请求
        new Thread() {
            public void run() {
                try {
                    BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                    PrintStream ps = new PrintStream(socket.getOutputStream());
                    ps.println("欢迎咨询传智播客");
                    System.out.println(br.readLine());
                    ps.println("报满了,请报下一期吧");
                    System.out.println(br.readLine());
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }.start();
    }
}
</code></pre>

<h3>26.19_网络编程(练习)</h3>
<ul>
<li>客户端向服务器写字符串(键盘录入),服务器(多线程)将字符串反转后写回,客户端再次读取到是反转后的字符串</li>
</ul>
<h3>26.20_网络编程(练习)</h3>
<ul>
<li>客户端向服务器上传文件</li>
</ul>
<h3>26.21_day26总结</h3>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>



<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
</body></html>